<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ikANS</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Montserrat:wght@300;400;500&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
    /* --- CSS RESET & BASE STYLES --- */
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        overflow: hidden;
        background-color: #020204;
        color: #ffffff;
        font-family: 'Montserrat', sans-serif;
    }

    /* --- CANVAS --- */
    #webgl-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        outline: none;
    }

    /* --- UI OVERLAY (LUXURY STYLE) --- */
    .ui-layer {
        position: fixed;
        z-index: 10;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 2rem;
    }

    header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        opacity: 0; /* Managed by GSAP now */
    }

    .brand {
        font-family: 'Orbitron', sans-serif;
        font-size: 1.2rem;
        letter-spacing: 4px;
        font-weight: 700;
        text-transform: uppercase;
        color: #ffffff;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        pointer-events: auto;
        cursor: pointer;
    }

    .menu-btn {
        font-size: 1.5rem;
        color: #00ffcc;
        cursor: pointer;
        pointer-events: auto;
        transition: transform 0.3s ease, color 0.3s ease;
    }

    .menu-btn:hover {
        color: #fff;
        transform: rotate(90deg);
    }

    /* Footer Info */
    footer {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        opacity: 0; /* Managed by GSAP now */
    }

    .coordinates {
        font-family: 'Orbitron', sans-serif;
        font-size: 0.7rem;
        color: rgba(255, 255, 255, 0.5);
        letter-spacing: 2px;
    }

    .socials {
        display: flex;
        gap: 20px;
        pointer-events: auto;
    }

    .socials i {
        font-size: 1.2rem;
        color: rgba(255, 255, 255, 0.6);
        transition: color 0.3s ease, transform 0.3s ease;
        cursor: pointer;
    }

    .socials i:hover {
        color: #00ffcc;
        transform: translateY(-3px);
        text-shadow: 0 0 8px #00ffcc;
    }

    /* Instruction Hint */
    .hint {
        position: absolute;
        bottom: 10%;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.8rem;
        letter-spacing: 3px;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.3);
        pointer-events: none;
        animation: pulse 3s infinite;
        opacity: 0;
    }

    /* --- NEW LUXURY LOADER STYLES --- */
    #loader {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: #020204;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    .loader-content {
        text-align: center;
        position: relative;
    }

    .loader-title {
        font-family: 'Cinzel', serif;
        font-size: 2rem;
        letter-spacing: 0.5rem;
        color: #fff;
        margin-bottom: 1rem;
        opacity: 0;
        transform: translateY(20px);
    }

    .loader-line {
        width: 0%;
        height: 1px;
        background: linear-gradient(90deg, transparent, #fff, transparent);
        margin: 0 auto;
    }

    .loader-sub {
        margin-top: 1rem;
        font-family: 'Orbitron', sans-serif;
        font-size: 0.6rem;
        letter-spacing: 0.3rem;
        color: rgba(255,255,255,0.5);
        text-transform: uppercase;
        opacity: 0;
    }

    /* --- ANIMATIONS --- */
    @keyframes pulse {
        0%, 100% { opacity: 0.3; }
        50% { opacity: 0.7; }
    }

    @media (max-width: 768px) {
        .ui-layer { padding: 1.5rem; }
        .brand { font-size: 1rem; }
        .loader-title { font-size: 1.5rem; }
    }
</style>
</head>
<body>

<div id="loader">
    <div class="loader-content">
        <div class="loader-title">Ik Answer</div>
        <div class="loader-line"></div>
      </div>
</div>

<canvas id="webgl-canvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // --- CONFIGURATION ---
    const config = {
        colors: {
            background: 0x020204,
            text: 0xffffff,
            textEmissive: 0x222222,
            glow: 0x00ffcc,
            nebula1: 0x6f42c1,
            nebula2: 0x1a1a2e
        },
        bloom: {
            strength: 1.5,
            radius: 0.4,
            threshold: 0
        }
    };

    // --- SCENE SETUP ---
    const canvas = document.querySelector('#webgl-canvas');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(config.colors.background);
    scene.fog = new THREE.FogExp2(config.colors.background, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ReinhardToneMapping;

    // --- POST PROCESSING (BLOOM) ---
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight), 
        config.bloom.strength, 
        config.bloom.radius, 
        config.bloom.threshold
    );

    const composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // --- LIGHTING ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
    scene.add(ambientLight);

    const pLight1 = new THREE.PointLight(config.colors.glow, 2, 50);
    pLight1.position.set(2, 2, 2);
    scene.add(pLight1);

    const pLight2 = new THREE.PointLight(config.colors.nebula1, 2, 50);
    pLight2.position.set(-2, -2, 1);
    scene.add(pLight2);

    // --- STARS (PARTICLES) ---
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 3000;
    const posArray = new Float32Array(starCount * 3);
    const colorArray = new Float32Array(starCount * 3);

    for(let i = 0; i < starCount * 3; i+=3) {
        posArray[i] = (Math.random() - 0.5) * 60;
        posArray[i+1] = (Math.random() - 0.5) * 60;
        posArray[i+2] = (Math.random() - 0.5) * 60;

        const colorMix = Math.random();
        if(colorMix > 0.8) {
            colorArray[i] = 0; colorArray[i+1] = 1; colorArray[i+2] = 0.8; 
        } else if (colorMix > 0.5) {
            colorArray[i] = 0.6; colorArray[i+1] = 0.2; colorArray[i+2] = 0.8; 
        } else {
            colorArray[i] = 0.8; colorArray[i+1] = 0.8; colorArray[i+2] = 1; 
        }
    }

    starGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    starGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

    const starMaterial = new THREE.PointsMaterial({
        size: 0.05,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
    });

    const starMesh = new THREE.Points(starGeometry, starMaterial);
    scene.add(starMesh);

    // --- THE "TOUCH" TEXT & INTERACTION ZONES ---
    let textMesh;
    let hitboxMesh;
    let isRevealed = false;

    const hitboxGeo = new THREE.SphereGeometry(1.5, 16, 16);
    const hitboxMat = new THREE.MeshBasicMaterial({ visible: false });
    hitboxMesh = new THREE.Mesh(hitboxGeo, hitboxMat);
    scene.add(hitboxMesh);

    const loader = new FontLoader();
    loader.load('https://threejs.org/examples/fonts/optimer_bold.typeface.json', function (font) {
        const textGeo = new TextGeometry('TOUCH', {
            font: font,
            size: 0.8,
            height: 0.2,
            curveSegments: 12,
            bevelEnabled: true,
            bevelThickness: 0.03,
            bevelSize: 0.02,
            bevelOffset: 0,
            bevelSegments: 5
        });

        textGeo.center();

        const textMat = new THREE.MeshPhysicalMaterial({
            color: config.colors.text,
            emissive: config.colors.textEmissive,
            emissiveIntensity: 0.2,
            metalness: 0.6,
            roughness: 0.1,
            clearcoat: 1,
            clearcoatRoughness: 0,
            reflectivity: 1
        });

        textMesh = new THREE.Mesh(textGeo, textMat);
        textMesh.scale.set(0, 0, 0);
        scene.add(textMesh);

        // TRIGGER THE NEW LOADER ANIMATION
        runLuxuryLoader();
    });

    // --- NEW LOADER GSAP SEQUENCE ---
    function runLuxuryLoader() {
        const tl = gsap.timeline();

        tl.to('.loader-title', { opacity: 1, y: 0, duration: 1, ease: "power2.out" })
          .to('.loader-line', { width: '100px', duration: 1, ease: "power2.out" }, "-=0.5")
          .to('.loader-sub', { opacity: 1, duration: 1 }, "-=0.5")
          .to({}, { duration: 1.0 }) 
          .to('.loader-title', { letterSpacing: '2rem', opacity: 0, duration: 1, ease: "power2.in" })
          .to('.loader-line', { width: '0%', duration: 0.5 }, "-=0.8")
          .to('.loader-sub', { opacity: 0, duration: 0.5 }, "-=0.8")
          .to('#loader', { opacity: 0, duration: 1, ease: "power2.inOut", onComplete: () => {
              document.getElementById('loader').style.display = 'none';
          }})
          // Reveal Main UI
          .to('#ui-header', { opacity: 1, duration: 1 }, "-=0.5")
          .to('#ui-footer', { opacity: 1, duration: 1 }, "-=1")
          .to('#ui-hint', { opacity: 1, duration: 1 }, "-=0.5");
    }

    // --- INTERACTION LOGIC ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function revealText() {
        if(!textMesh || isRevealed) return;
        isRevealed = true;
        gsap.to(textMesh.scale, { x: 1, y: 1, z: 1, duration: 1.5, ease: "elastic.out(1, 0.5)" });
        gsap.to(textMesh.rotation, { x: 0, y: 0, z: 0, duration: 1 });
        gsap.to(bloomPass, { strength: 2.5, duration: 0.5, yoyo: true, repeat: 1 });
        gsap.to(pLight1, { intensity: 4, duration: 0.5, yoyo: true, repeat: 1 });
    }

    function hideText() {
        if(!textMesh || !isRevealed) return;
        isRevealed = false;
        gsap.to(textMesh.scale, { x: 0, y: 0, z: 0, duration: 0.8, ease: "power2.in" });
    }

    function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        const targetX = mouse.x * 0.5;
        const targetY = mouse.y * 0.5;
        gsap.to(camera.position, { x: targetX, y: targetY, duration: 1 });
        checkIntersection();
    }

    function onTouch(event) {
        if(event.touches.length > 0) {
            mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
            checkIntersection();
        }
    }

    function checkIntersection() {
        if(!hitboxMesh) return;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(hitboxMesh);
        if (intersects.length > 0) {
            document.body.style.cursor = 'pointer';
            revealText();
        } else {
            document.body.style.cursor = 'default';
            hideText();
        }
    }

    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('click', checkIntersection);
    window.addEventListener('touchstart', onTouch);

    // --- ANIMATION LOOP ---
    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        const elapsedTime = clock.getElapsedTime();
        starMesh.rotation.y = elapsedTime * 0.05;
        starMesh.rotation.x = elapsedTime * 0.02;
        pLight1.position.x = Math.sin(elapsedTime * 0.7) * 3;
        pLight1.position.y = Math.cos(elapsedTime * 0.5) * 3;
        pLight2.position.x = Math.cos(elapsedTime * 0.3) * 4;
        pLight2.position.y = Math.sin(elapsedTime * 0.5) * 4;
        if(textMesh && isRevealed) {
            textMesh.position.y = Math.sin(elapsedTime) * 0.05;
            textMesh.rotation.y = Math.sin(elapsedTime * 0.5) * 0.1;
        }
        composer.render();
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
  </html>
